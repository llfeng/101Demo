###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               18/Jun/2021  17:52:23
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\SRC\DemoPrj\Components\hal\target\CC2530EB\hal_flash.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWC609.tmp
#        (D:\SRC\DemoPrj\Components\hal\target\CC2530EB\hal_flash.c -D
#        ZIGBEEPRO -D HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D LCD_SUPPORTED -lC
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List
#        -lA
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x1223
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED=3000
#        -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8
#        -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2
#        -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16
#        -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\ -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\SOURCE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List\hal_flash.lst
#    Object file        =  
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\Obj\hal_flash.r51
#
###############################################################################

D:\SRC\DemoPrj\Components\hal\target\CC2530EB\hal_flash.c
      1          /**************************************************************************************************
      2            Filename:       _hal_flash.c
      3            Revised:        $Date:$
      4            Revision:       $Revision:$
      5          
      6            Description: This file contains the interface to the H/W Flash driver.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          #include "hal_board_cfg.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc7
   \   unsigned char volatile __sfr MEMCTR
   \                     MEMCTR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr DMAIRQ
   \                     DMAIRQ:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr DMAARM
   \                     DMAARM:
   \   000000                DS 1
     46          #include "hal_dma.h"
     47          #include "hal_flash.h"
     48          #include "hal_types.h"
     49          
     50          /* ------------------------------------------------------------------------------------------------
     51           *                                           Macros
     52           * ------------------------------------------------------------------------------------------------
     53           */
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                          Constants
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          
     60          // These values depend on RAM_CODE_FLASH in the .xcl file used.
     61          #if defined CC2530F64  // RemoTI is using 0x01DDD --> pg 3, offset 0x5DD.
     62          #define OSET_OF_RAM_CODE  0x5DD
     63          #define PAGE_OF_RAM_CODE  3
     64          #define SIZE_OF_RAM_CODE  0x23
     65          #elif defined HAL_OAD_BOOT_CODE // OAD boot code does not use RAM copy
     66          #define OSET_OF_RAM_CODE  0x7E5
     67          #define PAGE_OF_RAM_CODE  0
     68          #define SIZE_OF_RAM_CODE  0x1B
     69          #else                   // Z-Stack is using 0x39DDD --> pg 51, offset 0x5DD.
     70          #define OSET_OF_RAM_CODE  0x5DD
     71          #define PAGE_OF_RAM_CODE  51
     72          #define SIZE_OF_RAM_CODE  0x23
     73          #endif
     74          
     75          /* ------------------------------------------------------------------------------------------------
     76           *                                          Typedefs
     77           * ------------------------------------------------------------------------------------------------
     78           */
     79          
     80          /* ------------------------------------------------------------------------------------------------
     81           *                                       Global Variables
     82           * ------------------------------------------------------------------------------------------------
     83           */
     84          
     85          /* ------------------------------------------------------------------------------------------------
     86           *                                       Global Functions
     87           * ------------------------------------------------------------------------------------------------
     88           */
     89          
     90          /* ------------------------------------------------------------------------------------------------
     91           *                                       Local Variables
     92           * ------------------------------------------------------------------------------------------------
     93           */
     94          
     95          #pragma location="RAM_CODE_XDATA"

   \                                 In  segment RAM_CODE_XDATA, align 1
     96          static __no_init uint8 ramCode[SIZE_OF_RAM_CODE];
   \                     ramCode:
   \   000000                DS 35
     97          
     98          /* ------------------------------------------------------------------------------------------------
     99           *                                       Local Functions
    100           * ------------------------------------------------------------------------------------------------
    101           */
    102          
    103          #pragma location="RAM_CODE_FLASH"
    104          #if defined HAL_OAD_BOOT_CODE
    105          static void HalFlashWriteTrigger(void);
    106          #else
    107          static __monitor void HalFlashWriteTrigger(void);
    108          #endif
    109          
    110          /**************************************************************************************************
    111           * @fn          HalFlashInit
    112           *
    113           * @brief       This function initializes the environment for this module.
    114           *
    115           * input parameters
    116           *
    117           * None.
    118           *
    119           * output parameters
    120           *
    121           * None.
    122           *
    123           * @return      None.
    124           **************************************************************************************************
    125           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    126          void HalFlashInit(void)
   \                     HalFlashInit:
    127          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    128            // Load the code to run from RAM into its reserved area of RAM once at startup.
    129            HalFlashRead(PAGE_OF_RAM_CODE, OSET_OF_RAM_CODE, ramCode, SIZE_OF_RAM_CODE);
   \   000005                ; Setup parameters for call to function HalFlashRead
   \   000005   75..23       MOV       ?V0,#0x23
   \   000008   75..00       MOV       ?V1,#0x0
   \   00000B   78..         MOV       R0,#?V0
   \   00000D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000010   7C..         MOV       R4,#ramCode & 0xff
   \   000012   7D..         MOV       R5,#(ramCode >> 8) & 0xff
   \   000014   7ADD         MOV       R2,#-0x23
   \   000016   7B05         MOV       R3,#0x5
   \   000018   7933         MOV       R1,#0x33
   \   00001A   12....       LCALL     `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   00001D   7402         MOV       A,#0x2
   \   00001F   12....       LCALL     ?DEALLOC_XSTACK8
    130          }
   \   000022                REQUIRE ?Subroutine0
   \   000022                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    131          
    132          /**************************************************************************************************
    133           * @fn          HalFlashRead
    134           *
    135           * @brief       This function reads 'cnt' bytes from the internal flash.
    136           *
    137           * input parameters
    138           *
    139           * @param       pg - A valid flash page number.
    140           * @param       offset - A valid offset into the page.
    141           * @param       buf - A valid buffer space at least as big as the 'cnt' parameter.
    142           * @param       cnt - A valid number of bytes to read.
    143           *
    144           * output parameters
    145           *
    146           * None.
    147           *
    148           * @return      None.
    149           **************************************************************************************************
    150           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    151          void HalFlashRead(uint8 pg, uint16 offset, uint8 *buf, uint16 cnt)
   \                     HalFlashRead:
    152          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    153            // Calculate the offset into the containing flash bank as it gets mapped into XDATA.
    154            uint8 *ptr = (uint8 *)(offset + HAL_FLASH_PAGE_MAP) +
    155                         ((pg % HAL_FLASH_PAGE_PER_BANK) * HAL_FLASH_PAGE_SIZE);
   \   000007   740F         MOV       A,#0xf
   \   000009   5E           ANL       A,R6
   \   00000A   F5..         MOV       ?V0,A
   \   00000C   75..00       MOV       ?V1,#0x0
   \   00000F   740B         MOV       A,#0xb
   \   000011   78..         MOV       R0,#?V0
   \   000013   12....       LCALL     ?S_SHL
   \   000016   EA           MOV       A,R2
   \   000017   2400         ADD       A,#0x0
   \   000019   F8           MOV       R0,A
   \   00001A   EB           MOV       A,R3
   \   00001B   3480         ADDC      A,#-0x80
   \   00001D   F9           MOV       R1,A
   \   00001E   EA           MOV       A,R2
   \   00001F   2400         ADD       A,#0x0
   \   000021   E9           MOV       A,R1
   \   000022   35..         ADDC      A,?V1
   \   000024   F9           MOV       R1,A
    156            uint8 memctr = MEMCTR;  // Save to restore.
   \   000025   AFC7         MOV       R7,0xc7+0x0
    157          
    158          #if !defined HAL_OAD_BOOT_CODE
    159            halIntState_t is;
    160          #endif
    161          
    162            pg /= HAL_FLASH_PAGE_PER_BANK;  // Calculate the flash bank from the flash page.
    163          
    164          #if !defined HAL_OAD_BOOT_CODE
    165            HAL_ENTER_CRITICAL_SECTION(is);
   \   000027   A2AF         MOV       C,0xa8.7
   \   000029   E4           CLR       A
   \   00002A   33           RLC       A
   \   00002B   F5..         MOV       ?V2,A
   \   00002D   C2AF         CLR       0xa8.7
    166          #endif
    167          
    168            // Calculate and map the containing flash bank into XDATA.
    169            MEMCTR = (MEMCTR & 0xF8) | pg;
   \   00002F   EE           MOV       A,R6
   \   000030   C4           SWAP      A
   \   000031   540F         ANL       A,#0xf
   \   000033   FA           MOV       R2,A
   \   000034   E5C7         MOV       A,0xc7
   \   000036   54F8         ANL       A,#0xf8
   \   000038   4A           ORL       A,R2
   \   000039   F5C7         MOV       0xc7,A
   \   00003B   740B         MOV       A,#0xb
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   E0           MOVX      A,@DPTR
   \   000041   FA           MOV       R2,A
   \   000042   A3           INC       DPTR
   \   000043   E0           MOVX      A,@DPTR
   \   000044   FB           MOV       R3,A
   \   000045   801C         SJMP      ??HalFlashRead_0
    170          
    171            while (cnt--)
    172            {
    173              *buf++ = *ptr++;
   \                     ??HalFlashRead_1:
   \   000047   8882         MOV       DPL,R0
   \   000049   8983         MOV       DPH,R1
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   8C82         MOV       DPL,R4
   \   00004E   8D83         MOV       DPH,R5
   \   000050   F0           MOVX      @DPTR,A
   \   000051   8882         MOV       DPL,R0
   \   000053   8983         MOV       DPH,R1
   \   000055   A3           INC       DPTR
   \   000056   A882         MOV       R0,DPL
   \   000058   A983         MOV       R1,DPH
   \   00005A   8C82         MOV       DPL,R4
   \   00005C   8D83         MOV       DPH,R5
   \   00005E   A3           INC       DPTR
   \   00005F   AC82         MOV       R4,DPL
   \   000061   AD83         MOV       R5,DPH
    174            }
   \                     ??HalFlashRead_0:
   \   000063   8A..         MOV       ?V0,R2
   \   000065   8B..         MOV       ?V1,R3
   \   000067   E5..         MOV       A,?V0
   \   000069   24FF         ADD       A,#-0x1
   \   00006B   1A           DEC       R2
   \   00006C   E5..         MOV       A,?V1
   \   00006E   34FF         ADDC      A,#-0x1
   \   000070   FB           MOV       R3,A
   \   000071   E5..         MOV       A,?V0
   \   000073   45..         ORL       A,?V1
   \   000075   70D0         JNZ       ??HalFlashRead_1
    175          
    176            MEMCTR = memctr;
   \   000077   8FC7         MOV       0xc7,R7
    177          
    178          #if !defined HAL_OAD_BOOT_CODE
    179            HAL_EXIT_CRITICAL_SECTION(is);
   \   000079   E5..         MOV       A,?V2
   \   00007B   A2E0         MOV       C,0xE0 /* A   */.0
   \   00007D   92AF         MOV       0xa8.7,C
    180          #endif
    181          }
   \   00007F   7F03         MOV       R7,#0x3
   \   000081   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   000084                REQUIRE MEMCTR
   \   000084                REQUIRE _A_IEN0
    182          
    183          /**************************************************************************************************
    184           * @fn          HalFlashWrite
    185           *
    186           * @brief       This function writes 'cnt' bytes to the internal flash.
    187           *
    188           * input parameters
    189           *
    190           * @param       addr - Valid HAL flash write address: actual addr / 4 and quad-aligned.
    191           * @param       buf - Valid buffer space at least as big as 'cnt' X 4.
    192           * @param       cnt - Number of 4-byte blocks to write.
    193           *
    194           * output parameters
    195           *
    196           * None.
    197           *
    198           * @return      None.
    199           **************************************************************************************************
    200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    201          void HalFlashWrite(uint16 addr, uint8 *buf, uint16 cnt)
   \                     HalFlashWrite:
    202          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    203            halDMADesc_t *ch = HAL_NV_DMA_GET_DESC();
    204          
    205            HAL_DMA_SET_SOURCE(ch, buf);
   \   000005   ED           MOV       A,R5
   \   000006   90....       MOV       DPTR,#dmaCh0
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   EC           MOV       A,R4
   \   00000B   A3           INC       DPTR
   \   00000C   F0           MOVX      @DPTR,A
    206            HAL_DMA_SET_DEST(ch, &FWDATA);
   \   00000D   A3           INC       DPTR
   \   00000E   7462         MOV       A,#0x62
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   7473         MOV       A,#0x73
   \   000014   F0           MOVX      @DPTR,A
    207            HAL_DMA_SET_VLEN(ch, HAL_DMA_VLEN_USE_LEN);
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   541F         ANL       A,#0x1f
   \   000019   F0           MOVX      @DPTR,A
   \   00001A   740A         MOV       A,#0xa
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   F5..         MOV       ?V0,A
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   F5..         MOV       ?V1,A
    208            HAL_DMA_SET_LEN(ch, (cnt * HAL_FLASH_WORD_SIZE));
   \   000026   E5..         MOV       A,?V0
   \   000028   33           RLC       A
   \   000029   33           RLC       A
   \   00002A   54FC         ANL       A,#0xfc
   \   00002C   90....       MOV       DPTR,#dmaCh0 + 5
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   7406         MOV       A,#0x6
   \   000032   78..         MOV       R0,#?V0
   \   000034   12....       LCALL     ?US_SHR
   \   000037   E5..         MOV       A,?V0
   \   000039   90....       MOV       DPTR,#dmaCh0 + 4
   \   00003C   F0           MOVX      @DPTR,A
    209            HAL_DMA_SET_WORD_SIZE(ch, HAL_DMA_WORDSIZE_BYTE);
    210            HAL_DMA_SET_TRIG_MODE(ch, HAL_DMA_TMODE_SINGLE);
    211            HAL_DMA_SET_TRIG_SRC(ch, HAL_DMA_TRIG_FLASH);
   \   00003D   90....       MOV       DPTR,#dmaCh0 + 6
   \   000040   7412         MOV       A,#0x12
   \   000042   F0           MOVX      @DPTR,A
    212            HAL_DMA_SET_SRC_INC(ch, HAL_DMA_SRCINC_1);
    213            HAL_DMA_SET_DST_INC(ch, HAL_DMA_DSTINC_0);
    214            // The DMA is to be polled and shall not issue an IRQ upon completion.
    215            HAL_DMA_SET_IRQ(ch, HAL_DMA_IRQMASK_DISABLE);
    216            HAL_DMA_SET_M8( ch, HAL_DMA_M8_USE_8_BITS);
    217            HAL_DMA_SET_PRIORITY(ch, HAL_DMA_PRI_HIGH);
   \   000043   A3           INC       DPTR
   \   000044   7442         MOV       A,#0x42
   \   000046   F0           MOVX      @DPTR,A
    218            HAL_DMA_CLEAR_IRQ(HAL_NV_DMA_CH);
   \   000047   53D1FE       ANL       0xd1,#0xfe
    219            HAL_DMA_ARM_CH(HAL_NV_DMA_CH);
   \   00004A   75D601       MOV       0xd6,#0x1
    220          
    221            FADDRL = (uint8)addr;
   \   00004D   EA           MOV       A,R2
   \   00004E   906271       MOV       DPTR,#0x6271
   \   000051   F0           MOVX      @DPTR,A
    222            FADDRH = (uint8)(addr >> 8);
   \   000052   EB           MOV       A,R3
   \   000053   A3           INC       DPTR
   \   000054   F0           MOVX      @DPTR,A
    223            HalFlashWriteTrigger();
   \   000055                ; Setup parameters for call to function HalFlashWriteTrigger
   \   000055   12....       LCALL     `??HalFlashWriteTrigger::?relay`; Banked call to: HalFlashWriteTrigger
    224          }
   \   000058   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   00005B                REQUIRE DMAIRQ
   \   00005B                REQUIRE DMAARM
    225          
    226          /**************************************************************************************************
    227           * @fn          HalFlashErase
    228           *
    229           * @brief       This function erases the specified page of the internal flash.
    230           *
    231           * input parameters
    232           *
    233           * @param       pg - A valid flash page number to erase.
    234           *
    235           * output parameters
    236           *
    237           * None.
    238           *
    239           * @return      None.
    240           **************************************************************************************************
    241           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    242          void HalFlashErase(uint8 pg)
   \                     HalFlashErase:
    243          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    244            FADDRH = pg * (HAL_FLASH_PAGE_SIZE / HAL_FLASH_WORD_SIZE / 256);
   \   000004   E9           MOV       A,R1
   \   000005   C3           CLR       C
   \   000006   33           RLC       A
   \   000007   906272       MOV       DPTR,#0x6272
   \   00000A   F0           MOVX      @DPTR,A
    245            FCTL |= 0x01;
   \   00000B   906270       MOV       DPTR,#0x6270
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   D2E0         SETB      0xE0 /* A   */.0
   \   000011   F0           MOVX      @DPTR,A
    246          }
   \   000012   D083         POP       DPH
   \   000014   D082         POP       DPL
   \   000016   02....       LJMP      ?BRET
    247          
    248          /**************************************************************************************************
    249           * @fn          HalFlashWriteTrigger
    250           *
    251           * @brief       This function must be copied to RAM before running because it triggers and then
    252           *              awaits completion of Flash write, which can only be done from RAM.
    253           *
    254           * input parameters
    255           *
    256           * None.
    257           *
    258           * output parameters
    259           *
    260           * None.
    261           *
    262           * @return      None.
    263           **************************************************************************************************
    264           */
    265          #if defined HAL_OAD_BOOT_CODE
    266          #pragma optimize=medium
    267          static void HalFlashWriteTrigger(void)
    268          #else

   \                                 In  segment RAM_CODE_FLASH, align 1, keep-with-next
    269          static __monitor void HalFlashWriteTrigger(void)
   \                     HalFlashWriteTrigger:
    270          #endif
    271          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   C0A8         PUSH      0xA8 /* IE  */
   \   000006   C2AF         CLR       0xA8 /* IE  */.7
    272            MEMCTR |= 0x08;       // Start the Memory Arbiter running CODE from RAM.
   \   000008   43C708       ORL       0xc7,#0x8
    273            FCTL |= 0x02;         // Trigger the DMA writes.
   \   00000B   906270       MOV       DPTR,#0x6270
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   D2E1         SETB      0xE0 /* A   */.1
   \   000011   F0           MOVX      @DPTR,A
    274            while (FCTL & 0x80);  // Wait until writing is done.
   \                     ??HalFlashWriteTrigger_0:
   \   000012   E0           MOVX      A,@DPTR
   \   000013   A2E7         MOV       C,0xE0 /* A   */.7
   \   000015   40FB         JC        ??HalFlashWriteTrigger_0
    275            MEMCTR &= ~0x08;      // Stop the Memory Arbiter.
   \   000017   53C7F7       ANL       0xc7,#0xf7
    276          }
   \   00001A   D0E0         POP       A
   \   00001C   A2E7         MOV       C,0xE0 /* A   */.7
   \   00001E   92AF         MOV       0xA8 /* IE  */.7,C
   \   000020   D083         POP       DPH
   \   000022   D082         POP       DPL
   \   000024   02....       LJMP      ?BRET
   \   000027                REQUIRE MEMCTR

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalFlashInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalFlashRead::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalFlashWrite::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalFlashErase::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashErase

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalFlashWriteTrigger::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalFlashWriteTrigger
    277          
    278          /**************************************************************************************************
    279          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   HalFlashErase
      0     12   HalFlashInit
        0     12   -> HalFlashRead
      1     23   HalFlashRead
      0     12   HalFlashWrite
        0     10   -> HalFlashWriteTrigger
      3     10   HalFlashWriteTrigger


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?Subroutine0
       1  DMAARM
       1  DMAIRQ
      25  HalFlashErase
       6  HalFlashErase::?relay
      34  HalFlashInit
       6  HalFlashInit::?relay
     132  HalFlashRead
       6  HalFlashRead::?relay
      91  HalFlashWrite
       6  HalFlashWrite::?relay
      39  HalFlashWriteTrigger
       6  HalFlashWriteTrigger::?relay
       1  MEMCTR
       1  _A_IEN0
      35  ramCode

 
 287 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
  39 bytes in segment RAM_CODE_FLASH
  35 bytes in segment RAM_CODE_XDATA
   4 bytes in segment SFR_AN
 
  30 bytes of CODE     memory
   0 bytes of DATA     memory (+ 4 bytes shared)
 326 bytes of HUGECODE memory
  35 bytes of XDATA    memory

Errors: none
Warnings: none

###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               18/Jun/2021  17:52:28
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\SRC\DemoPrj\Projects\zstack\ZMain\TI2530DB\OnBoard.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWD903.tmp
#        (D:\SRC\DemoPrj\Projects\zstack\ZMain\TI2530DB\OnBoard.c -D ZIGBEEPRO
#        -D HAL_UART=TRUE -D SERIAL_APP_PORT=0 -D LCD_SUPPORTED -lC
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List
#        -lA
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x1223
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED=3000
#        -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8
#        -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2
#        -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16
#        -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\ -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\SOURCE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\
#        -I
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\List\OnBoard.lst
#    Object file        =  
#        D:\SRC\DemoPrj\Projects\zstack\Utilities\SerialApp\CC2530DB\CoordinatorEB-Pro\Obj\OnBoard.r51
#
###############################################################################

D:\SRC\DemoPrj\Projects\zstack\ZMain\TI2530DB\OnBoard.c
      1          /**************************************************************************************************
      2            Filename:       OnBoard.c
      3            Revised:        $Date: 2009-03-12 16:26:27 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19405 $
      5          
      6            Description:    This file contains the UI and control for the
      7                            peripherals on the EVAL development board
      8            Notes:          This file targets the Chipcon CC2530
      9          
     10          
     11            Copyright 2005-2008 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License").  You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product.  Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          
     46          #include "ZComDef.h"
     47          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     48          #include "OSAL.h"
     49          #include "MT.h"
     50          #include "MT_SYS.h"
     51          #include "DebugTrace.h"
     52          
     53          /* Hal */
     54          #include "hal_lcd.h"
     55          #include "hal_mcu.h"
     56          #include "hal_timer.h"
     57          #include "hal_key.h"
     58          #include "hal_led.h"
     59          
     60          /*********************************************************************
     61           * MACROS
     62           */
     63          
     64          /*********************************************************************
     65           * CONSTANTS
     66           */
     67          
     68          // Task ID not initialized
     69          #define NO_TASK_ID 0xFF
     70          
     71          // Minimum length RAM "pattern" for Stack check
     72          #define MIN_RAM_INIT 12
     73          
     74          /*********************************************************************
     75           * TYPEDEFS
     76           */
     77          
     78          /*********************************************************************
     79           * GLOBAL VARIABLES
     80           */
     81          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     82          uint8 OnboardKeyIntEnable;
   \                     OnboardKeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     83          
     84          // 64-bit Extended Address of this device

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     85          uint8 aExtendedAddress[8];
   \                     aExtendedAddress:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
     86          
     87          /*********************************************************************
     88           * EXTERNAL VARIABLES
     89           */
     90          
     91          /*********************************************************************
     92           * EXTERNAL FUNCTIONS
     93           */
     94          
     95          extern uint8 macMcuRandomByte(void);
     96          
     97          /*********************************************************************
     98           * LOCAL VARIABLES
     99           */
    100          
    101          // Registered keys task ID, initialized to NOT USED.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    102          static byte registeredKeysTaskID = NO_TASK_ID;
   \                     registeredKeysTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for registeredKeysTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    103          
    104          /*********************************************************************
    105           * LOCAL FUNCTIONS
    106           */
    107          
    108          static void ChkReset( void );
    109          
    110          /*********************************************************************
    111           * @fn      InitBoard()
    112           * @brief   Initialize the CC2420DB Board Peripherals
    113           * @param   level: COLD,WARM,READY
    114           * @return  None
    115           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    116          void InitBoard( byte level )
   \                     InitBoard:
    117          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
    118            if ( level == OB_COLD )
   \   000006   7053         JNZ       ??InitBoard_0
    119            {
    120              // Interrupts off
    121              osal_int_disable( INTS_ALL );
   \   000008                ; Setup parameters for call to function osal_int_disable
   \   000008   79FF         MOV       R1,#-0x1
   \   00000A   12....       LCALL     `??osal_int_disable::?relay`; Banked call to: osal_int_disable
    122              // Turn all LEDs off
    123              HalLedSet( HAL_LED_ALL, HAL_LED_MODE_OFF );
   \   00000D                ; Setup parameters for call to function HalLedSet
   \   00000D   7A00         MOV       R2,#0x0
   \   00000F   793F         MOV       R1,#0x3f
   \   000011   12....       LCALL     `??HalLedSet::?relay`; Banked call to: HalLedSet
    124              // Check for Brown-Out reset
    125              ChkReset();
   \   000014   E59D         MOV       A,0x9d
   \   000016   5418         ANL       A,#0x18
   \   000018   F8           MOV       R0,A
   \   000019   604D         JZ        ??InitBoard_1
   \   00001B   7408         MOV       A,#0x8
   \   00001D   68           XRL       A,R0
   \   00001E   6048         JZ        ??InitBoard_1
   \   000020   7410         MOV       A,#0x10
   \   000022   68           XRL       A,R0
   \   000023   6043         JZ        ??InitBoard_1
   \   000025   C2AF         CLR       0xa8.7
   \                     ??InitBoard_2:
   \   000027   7E08         MOV       R6,#0x8
   \                     ??InitBoard_3:
   \   000029                ; Setup parameters for call to function HalLedSet
   \   000029   7A01         MOV       R2,#0x1
   \   00002B   EE           MOV       A,R6
   \   00002C   F9           MOV       R1,A
   \   00002D   12....       LCALL     `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   000030                ; Setup parameters for call to function Onboard_wait
   \   000030   7A24         MOV       R2,#0x24
   \   000032   7BF4         MOV       R3,#-0xc
   \   000034   12....       LCALL     `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \   000037                ; Setup parameters for call to function Onboard_wait
   \   000037   7A24         MOV       R2,#0x24
   \   000039   7BF4         MOV       R3,#-0xc
   \   00003B   12....       LCALL     `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \   00003E                ; Setup parameters for call to function HalLedSet
   \   00003E   7A00         MOV       R2,#0x0
   \   000040   EE           MOV       A,R6
   \   000041   F9           MOV       R1,A
   \   000042   12....       LCALL     `??HalLedSet::?relay`; Banked call to: HalLedSet
   \   000045                ; Setup parameters for call to function Onboard_wait
   \   000045   7A7C         MOV       R2,#0x7c
   \   000047   7B92         MOV       R3,#-0x6e
   \   000049   12....       LCALL     `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \   00004C                ; Setup parameters for call to function Onboard_wait
   \   00004C   7A7C         MOV       R2,#0x7c
   \   00004E   7B92         MOV       R3,#-0x6e
   \   000050   12....       LCALL     `??Onboard_wait::?relay`; Banked call to: Onboard_wait
   \   000053   EE           MOV       A,R6
   \   000054   C3           CLR       C
   \   000055   13           RRC       A
   \   000056   FE           MOV       R6,A
   \   000057   70D0         JNZ       ??InitBoard_3
   \   000059   80CC         SJMP      ??InitBoard_2
    126            }
    127            else  // !OB_COLD
    128            {
    129          #ifdef ZTOOL_PORT
    130              MT_SysResetInd();
    131          #endif
    132          
    133               /* Initialize Key stuff */
    134              OnboardKeyIntEnable = HAL_KEY_INTERRUPT_DISABLE;
   \                     ??InitBoard_0:
   \   00005B   90....       MOV       DPTR,#OnboardKeyIntEnable
   \   00005E   E4           CLR       A
   \   00005F   F0           MOVX      @DPTR,A
    135              HalKeyConfig( OnboardKeyIntEnable, OnBoard_KeyCallback);
   \   000060                ; Setup parameters for call to function HalKeyConfig
   \   000060   7A..         MOV       R2,#`??OnBoard_KeyCallback::?relay` & 0xff
   \   000062   7B..         MOV       R3,#(`??OnBoard_KeyCallback::?relay` >> 8) & 0xff
   \   000064   F9           MOV       R1,A
   \   000065   12....       LCALL     `??HalKeyConfig::?relay`; Banked call to: HalKeyConfig
    136            }
    137          }
   \                     ??InitBoard_1:
   \   000068                REQUIRE ?Subroutine0
   \   000068                REQUIRE SLEEPSTA
   \   000068                REQUIRE _A_IEN0
   \   000068                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    138          
    139          /*********************************************************************
    140           * @fn      ChkReset()
    141           * @brief   Check reset bits - if reset cause is unknown, assume a
    142           *          brown-out (low power), assume batteries are not reliable,
    143           *          hang in a loop and sequence through the LEDs.
    144           * @param   None
    145           * @return  None
    146           *********************************************************************/
    147          void ChkReset( void )
    148          {
    149            uint8 led;
    150            uint8 rib;
    151          
    152            // Isolate reset indicator bits
    153            rib = SLEEPSTA & LRESET;
    154          
    155            if ( rib == RESETPO )
    156            {
    157              // Put code here to handle Power-On reset
    158            }
    159            else if ( rib == RESETEX )
    160            {
    161              // Put code here to handle External reset
    162            }
    163            else if ( rib == RESETWD )
    164            {
    165              // Put code here to handle WatchDog reset
    166            }
    167            else
    168            {
    169              // Unknown, hang and blink
    170              HAL_DISABLE_INTERRUPTS();
    171              led = HAL_LED_4;
    172              while ( 1 ) {
    173                HalLedSet( led, HAL_LED_MODE_ON );
    174                MicroWait( 62500 );
    175                MicroWait( 62500 );
    176                HalLedSet( led, HAL_LED_MODE_OFF );
    177                MicroWait( 37500 );
    178                MicroWait( 37500 );
    179                if ( !(led >>= 1) )
    180                  led = HAL_LED_4;
    181              }
    182            }
    183          }
    184          
    185          /*********************************************************************
    186           *                        "Keyboard" Support
    187           *********************************************************************/
    188          
    189          /*********************************************************************
    190           * Keyboard Register function
    191           *
    192           * The keyboard handler is setup to send all keyboard changes to
    193           * one task (if a task is registered).
    194           *
    195           * If a task registers, it will get all the keys. You can change this
    196           * to register for individual keys.
    197           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    198          byte RegisterForKeys( byte task_id )
   \                     RegisterForKeys:
    199          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    200            // Allow only the first task
    201            if ( registeredKeysTaskID == NO_TASK_ID )
   \   000004   90....       MOV       DPTR,#registeredKeysTaskID
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F4           CPL       A
   \   000009   7006         JNZ       ??RegisterForKeys_0
    202            {
    203              registeredKeysTaskID = task_id;
   \   00000B   E9           MOV       A,R1
   \   00000C   F0           MOVX      @DPTR,A
    204              return ( true );
   \   00000D   7901         MOV       R1,#0x1
   \   00000F   8002         SJMP      ??RegisterForKeys_1
    205            }
    206            else
    207              return ( false );
   \                     ??RegisterForKeys_0:
   \   000011   7900         MOV       R1,#0x0
   \                     ??RegisterForKeys_1:
   \   000013                REQUIRE ?Subroutine1
   \   000013                ; // Fall through to label ?Subroutine1
    208          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    209          
    210          /*********************************************************************
    211           * @fn      OnBoard_SendKeys
    212           *
    213           * @brief   Send "Key Pressed" message to application.
    214           *
    215           * @param   keys  - keys that were pressed
    216           *          state - shifted
    217           *
    218           * @return  status
    219           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    220          byte OnBoard_SendKeys( byte keys, byte state )
   \                     OnBoard_SendKeys:
    221          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   \   000007   EA           MOV       A,R2
   \   000008   FF           MOV       R7,A
    222            keyChange_t *msgPtr;
    223          
    224            if ( registeredKeysTaskID != NO_TASK_ID )
   \   000009   90....       MOV       DPTR,#registeredKeysTaskID
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F4           CPL       A
   \   00000E   602B         JZ        ??OnBoard_SendKeys_0
    225            {
    226              // Send the address to the task
    227              msgPtr = (keyChange_t *)osal_msg_allocate( sizeof(keyChange_t) );
   \   000010                ; Setup parameters for call to function osal_msg_allocate
   \   000010   7A04         MOV       R2,#0x4
   \   000012   7B00         MOV       R3,#0x0
   \   000014   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
    228              if ( msgPtr )
   \   000017   EA           MOV       A,R2
   \   000018   4B           ORL       A,R3
   \   000019   601C         JZ        ??OnBoard_SendKeys_1
    229              {
    230                msgPtr->hdr.event = KEY_CHANGE;
   \   00001B   8A82         MOV       DPL,R2
   \   00001D   8B83         MOV       DPH,R3
   \   00001F   74C0         MOV       A,#-0x40
   \   000021   F0           MOVX      @DPTR,A
    231                msgPtr->state = state;
   \   000022   EF           MOV       A,R7
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   F0           MOVX      @DPTR,A
    232                msgPtr->keys = keys;
   \   000026   EE           MOV       A,R6
   \   000027   8A82         MOV       DPL,R2
   \   000029   8B83         MOV       DPH,R3
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   F0           MOVX      @DPTR,A
    233          
    234                osal_msg_send( registeredKeysTaskID, (uint8 *)msgPtr );
   \   00002F                ; Setup parameters for call to function osal_msg_send
   \   00002F   90....       MOV       DPTR,#registeredKeysTaskID
   \   000032   E0           MOVX      A,@DPTR
   \   000033   F9           MOV       R1,A
   \   000034   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
    235              }
    236              return ( ZSuccess );
   \                     ??OnBoard_SendKeys_1:
   \   000037   7900         MOV       R1,#0x0
   \   000039   8002         SJMP      ??OnBoard_SendKeys_2
    237            }
    238            else
    239              return ( ZFailure );
   \                     ??OnBoard_SendKeys_0:
   \   00003B   7901         MOV       R1,#0x1
   \                     ??OnBoard_SendKeys_2:
   \   00003D   7F02         MOV       R7,#0x2
   \   00003F   02....       LJMP      ?BANKED_LEAVE_XDATA
    240          }
    241          
    242          /*********************************************************************
    243           * @fn      OnBoard_KeyCallback
    244           *
    245           * @brief   Callback service for keys
    246           *
    247           * @param   keys  - keys that were pressed
    248           *          state - shifted
    249           *
    250           * @return  void
    251           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    252          void OnBoard_KeyCallback ( uint8 keys, uint8 state )
   \                     OnBoard_KeyCallback:
    253          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    254            uint8 shift;
    255            
    256            (void)state;  // Intentionally unreferenced parameter
    257          
    258            // shift key (S1) is used to generate key interrupt
    259            // applications should not use S1 when key interrupt is enabled
    260            shift = (OnboardKeyIntEnable == HAL_KEY_INTERRUPT_ENABLE) ? false : ((keys & HAL_KEY_SW_6) ? true : false);
   \   000005   90....       MOV       DPTR,#OnboardKeyIntEnable
   \   000008   E0           MOVX      A,@DPTR
   \   000009   6401         XRL       A,#0x1
   \   00000B   7004         JNZ       ??OnBoard_KeyCallback_0
   \   00000D   7A00         MOV       R2,#0x0
   \   00000F   8010         SJMP      ??OnBoard_KeyCallback_1
   \                     ??OnBoard_KeyCallback_0:
   \   000011   E9           MOV       A,R1
   \   000012   A2E5         MOV       C,0xE0 /* A   */.5
   \   000014   5004         JNC       ??OnBoard_KeyCallback_2
   \   000016   D2F0         SETB      B.0
   \   000018   8002         SJMP      ??OnBoard_KeyCallback_3
   \                     ??OnBoard_KeyCallback_2:
   \   00001A   C2F0         CLR       B.0
   \                     ??OnBoard_KeyCallback_3:
   \   00001C   A2F0         MOV       C,B.0
   \   00001E   E4           CLR       A
   \   00001F   33           RLC       A
   \   000020   FA           MOV       R2,A
    261          
    262            if ( OnBoard_SendKeys( keys, shift ) != ZSuccess )
   \                     ??OnBoard_KeyCallback_1:
   \   000021                ; Setup parameters for call to function OnBoard_SendKeys
   \   000021   12....       LCALL     `??OnBoard_SendKeys::?relay`; Banked call to: OnBoard_SendKeys
    263            {
    264              // Process SW1 here
    265              if ( keys & HAL_KEY_SW_1 )  // Switch 1
    266              {
    267              }
    268              // Process SW2 here
    269              if ( keys & HAL_KEY_SW_2 )  // Switch 2
    270              {
    271              }
    272              // Process SW3 here
    273              if ( keys & HAL_KEY_SW_3 )  // Switch 3
    274              {
    275              }
    276              // Process SW4 here
    277              if ( keys & HAL_KEY_SW_4 )  // Switch 4
    278              {
    279              }
    280              // Process SW5 here
    281              if ( keys & HAL_KEY_SW_5 )  // Switch 5
    282              {
    283              }
    284              // Process SW6 here
    285              if ( keys & HAL_KEY_SW_6 )  // Switch 6
    286              {
    287              }
    288            }
    289          }
   \   000024   02....       LJMP      ?Subroutine0 & 0xFFFF
    290          
    291          /*********************************************************************
    292           *                    SLEEP MANAGEMENT FUNCTIONS
    293           *
    294           * These functions support processing of MAC and ZStack power mode
    295           * transitions, used when the system goes into or awakes from sleep.
    296           */
    297          
    298           /*********************************************************************
    299           * @fn      OnBoard_stack_used()
    300           *
    301           * @brief
    302           *
    303           *   Runs through the stack looking for touched memory.
    304           *
    305           * @param   none
    306           *
    307           * @return  number of bytes used by the stack
    308           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    309          uint16 OnBoard_stack_used( void )
   \                     OnBoard_stack_used:
    310          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    311            byte *pStack = (byte*)MCU_RAM_END;
   \   000004   78FF         MOV       R0,#-0x1
   \   000006   79FF         MOV       R1,#-0x1
    312            byte *pHold;
    313            byte found = false;
    314            byte x;
    315          
    316            // Look from the end of RAM for MIN_RAM_INIT number of "pattern" bytes
    317            // This should be the high water stack mark.
    318            while ( !found && pStack )
    319            {
    320              // Found an init value?
    321              if ( *pStack == STACK_INIT_VALUE )
   \                     ??OnBoard_stack_used_0:
   \   000008   8882         MOV       DPL,R0
   \   00000A   8983         MOV       DPH,R1
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   64CD         XRL       A,#0xcd
   \   00000F   7020         JNZ       ??OnBoard_stack_used_1
    322              {
    323                // Look for a bunch in a row
    324                pHold = pStack;
    325                for ( x = 0; x < MIN_RAM_INIT; x++ )
   \   000011   7A00         MOV       R2,#0x0
    326                {
    327                  if ( *pHold != STACK_INIT_VALUE )
   \                     ??OnBoard_stack_used_2:
   \   000013   E0           MOVX      A,@DPTR
   \   000014   64CD         XRL       A,#0xcd
   \   000016   7013         JNZ       ??OnBoard_stack_used_3
    328                    break;
    329                  else
    330                    pHold--;
   \   000018   E582         MOV       A,DPL
   \   00001A   24FF         ADD       A,#-0x1
   \   00001C   F582         MOV       DPL,A
   \   00001E   E583         MOV       A,DPH
   \   000020   34FF         ADDC      A,#-0x1
   \   000022   F583         MOV       DPH,A
    331                }
   \   000024   0A           INC       R2
   \   000025   EA           MOV       A,R2
   \   000026   C3           CLR       C
   \   000027   940C         SUBB      A,#0xc
   \   000029   40E8         JC        ??OnBoard_stack_used_2
    332                // Did we find the needed minimum number in a row
    333                if ( x >= MIN_RAM_INIT )
   \                     ??OnBoard_stack_used_3:
   \   00002B   EA           MOV       A,R2
   \   00002C   C3           CLR       C
   \   00002D   940C         SUBB      A,#0xc
   \   00002F   5013         JNC       ??OnBoard_stack_used_4
    334                  found = true;
    335              }
    336              if ( !found )
    337                pStack--;
   \                     ??OnBoard_stack_used_1:
   \   000031   E8           MOV       A,R0
   \   000032   24FF         ADD       A,#-0x1
   \   000034   18           DEC       R0
   \   000035   E9           MOV       A,R1
   \   000036   34FF         ADDC      A,#-0x1
   \   000038   F9           MOV       R1,A
    338            }
   \   000039   E8           MOV       A,R0
   \   00003A   49           ORL       A,R1
   \   00003B   70CB         JNZ       ??OnBoard_stack_used_0
    339          
    340            if ( pStack )
    341              return ( (uint16)((byte*)MCU_RAM_END - pStack) );
    342            else
    343              return ( 0 );
   \                     ??OnBoard_stack_used_5:
   \   00003D   7A00         MOV       R2,#0x0
   \   00003F   7B00         MOV       R3,#0x0
   \                     ??OnBoard_stack_used_6:
   \   000041   02....       LJMP      ?Subroutine1 & 0xFFFF
   \                     ??OnBoard_stack_used_4:
   \   000044   E8           MOV       A,R0
   \   000045   49           ORL       A,R1
   \   000046   60F5         JZ        ??OnBoard_stack_used_5
   \   000048   74FF         MOV       A,#-0x1
   \   00004A   C3           CLR       C
   \   00004B   98           SUBB      A,R0
   \   00004C   FA           MOV       R2,A
   \   00004D   74FF         MOV       A,#-0x1
   \   00004F   99           SUBB      A,R1
   \   000050   FB           MOV       R3,A
   \   000051   80EE         SJMP      ??OnBoard_stack_used_6
    344          }
    345          
    346          /*********************************************************************
    347           * @fn      _itoa
    348           *
    349           * @brief   convert a 16bit number to ASCII
    350           *
    351           * @param   num -
    352           *          buf -
    353           *          radix -
    354           *
    355           * @return  void
    356           *
    357           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    358          void _itoa(uint16 num, byte *buf, byte radix)
   \                     _itoa:
    359          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV       A,#-0x5
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   89..         MOV       ?V5,R1
    360            char c,i;
    361            byte *p, rst[5];
    362          
    363            p = rst;
   \   000010   A8..         MOV       R0,?XSP + 0
   \   000012   A9..         MOV       R1,?XSP + 1
   \   000014   88..         MOV       ?V0,R0
   \   000016   89..         MOV       ?V1,R1
    364            for ( i=0; i<5; i++,p++ )
   \   000018   75..00       MOV       ?V4,#0x0
   \   00001B   E5..         MOV       A,?V5
   \   00001D   F5..         MOV       ?V6,A
   \   00001F   75..00       MOV       ?V7,#0x0
    365            {
    366              c = num % radix;  // Isolate a digit
   \                     ??_itoa_0:
   \   000022   EE           MOV       A,R6
   \   000023   F8           MOV       R0,A
   \   000024   EF           MOV       A,R7
   \   000025   F9           MOV       R1,A
   \   000026   AA..         MOV       R2,?V6
   \   000028   AB..         MOV       R3,?V7
   \   00002A   12....       LCALL     ?US_DIV_MOD
   \   00002D   EA           MOV       A,R2
   \   00002E   F8           MOV       R0,A
    367              *p = c + (( c < 10 ) ? '0' : '7');  // Convert to Ascii
   \   00002F   940A         SUBB      A,#0xa
   \   000031   5004         JNC       ??_itoa_1
   \   000033   7930         MOV       R1,#0x30
   \   000035   8002         SJMP      ??_itoa_2
   \                     ??_itoa_1:
   \   000037   7937         MOV       R1,#0x37
   \                     ??_itoa_2:
   \   000039   EA           MOV       A,R2
   \   00003A   29           ADD       A,R1
   \   00003B   85..82       MOV       DPL,?V0
   \   00003E   85..83       MOV       DPH,?V1
   \   000041   F0           MOVX      @DPTR,A
    368              num /= radix;
   \   000042   EE           MOV       A,R6
   \   000043   F8           MOV       R0,A
   \   000044   EF           MOV       A,R7
   \   000045   F9           MOV       R1,A
   \   000046   AA..         MOV       R2,?V6
   \   000048   AB..         MOV       R3,?V7
   \   00004A   12....       LCALL     ?US_DIV_MOD
   \   00004D   88..         MOV       ?V2,R0
   \   00004F   89..         MOV       ?V3,R1
   \   000051   AE..         MOV       R6,?V2
   \   000053   AF..         MOV       R7,?V3
    369              if ( !num )
   \   000055   E8           MOV       A,R0
   \   000056   4F           ORL       A,R7
   \   000057   600F         JZ        ??_itoa_3
    370                break;
    371            }
   \   000059   05..         INC       ?V4
   \   00005B   A3           INC       DPTR
   \   00005C   8582..       MOV       ?V0,DPL
   \   00005F   8583..       MOV       ?V1,DPH
   \   000062   E5..         MOV       A,?V4
   \   000064   9405         SUBB      A,#0x5
   \   000066   40BA         JC        ??_itoa_0
    372          
    373            for ( c=0 ; c<=i; c++ )
   \                     ??_itoa_3:
   \   000068   7800         MOV       R0,#0x0
    374              *buf++ = *p--;  // Reverse character order
   \                     ??_itoa_4:
   \   00006A   85..82       MOV       DPL,?V0
   \   00006D   85..83       MOV       DPH,?V1
   \   000070   E0           MOVX      A,@DPTR
   \   000071   8C82         MOV       DPL,R4
   \   000073   8D83         MOV       DPH,R5
   \   000075   F0           MOVX      @DPTR,A
   \   000076   E5..         MOV       A,?V0
   \   000078   24FF         ADD       A,#-0x1
   \   00007A   F5..         MOV       ?V0,A
   \   00007C   E5..         MOV       A,?V1
   \   00007E   34FF         ADDC      A,#-0x1
   \   000080   F5..         MOV       ?V1,A
   \   000082   A3           INC       DPTR
   \   000083   AC82         MOV       R4,DPL
   \   000085   AD83         MOV       R5,DPH
   \   000087   08           INC       R0
   \   000088   E5..         MOV       A,?V4
   \   00008A   C3           CLR       C
   \   00008B   98           SUBB      A,R0
   \   00008C   50DC         JNC       ??_itoa_4
    375          
    376            *buf = '\0';
   \   00008E   E4           CLR       A
   \   00008F   F0           MOVX      @DPTR,A
    377          }
   \   000090   7405         MOV       A,#0x5
   \   000092   12....       LCALL     ?DEALLOC_XSTACK8
   \   000095   7F08         MOV       R7,#0x8
   \   000097   02....       LJMP      ?BANKED_LEAVE_XDATA
    378          
    379          /*********************************************************************
    380           * @fn        Onboard_rand
    381           *
    382           * @brief    Random number generator
    383           *
    384           * @param   none
    385           *
    386           * @return  uint16 - new random number
    387           *
    388           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    389          uint16 Onboard_rand( void )
   \                     Onboard_rand:
    390          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    391            uint16 randNum;
    392          
    393            randNum = macMcuRandomByte();
   \   000005                ; Setup parameters for call to function macMcuRandomByte
   \   000005   12....       LCALL     `??macMcuRandomByte::?relay`; Banked call to: macMcuRandomByte
   \   000008   E9           MOV       A,R1
    394            randNum += (macMcuRandomByte() << 8);
    395            return ( randNum );
   \   000009   FE           MOV       R6,A
   \   00000A                ; Setup parameters for call to function macMcuRandomByte
   \   00000A   12....       LCALL     `??macMcuRandomByte::?relay`; Banked call to: macMcuRandomByte
   \   00000D   EE           MOV       A,R6
   \   00000E   2400         ADD       A,#0x0
   \   000010   FA           MOV       R2,A
   \   000011   E4           CLR       A
   \   000012   39           ADDC      A,R1
   \   000013   FB           MOV       R3,A
   \   000014   02....       LJMP      ?Subroutine0 & 0xFFFF
    396          }
    397          
    398          /*********************************************************************
    399           * @fn        Onboard_wait
    400           *
    401           * @brief    Random number generator
    402           *
    403           * @param   uint16 - time to wait
    404           *
    405           * @return  none
    406           *
    407           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          void Onboard_wait( uint16 timeout )
   \                     Onboard_wait:
    409          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8003         SJMP      ??Onboard_wait_0
    410            while (timeout--)
    411            {
    412              asm("NOP");
   \                     ??Onboard_wait_1:
   \   000002   00           NOP
    413              asm("NOP");
   \   000003   00           NOP
    414              asm("NOP");
   \   000004   00           NOP
    415            }
   \                     ??Onboard_wait_0:
   \   000005   EA           MOV       A,R2
   \   000006   F8           MOV       R0,A
   \   000007   EB           MOV       A,R3
   \   000008   F9           MOV       R1,A
   \   000009   E8           MOV       A,R0
   \   00000A   24FF         ADD       A,#-0x1
   \   00000C   1A           DEC       R2
   \   00000D   E9           MOV       A,R1
   \   00000E   34FF         ADDC      A,#-0x1
   \   000010   FB           MOV       R3,A
   \   000011   E8           MOV       A,R0
   \   000012   49           ORL       A,R1
   \   000013   70ED         JNZ       ??Onboard_wait_1
    416          }
   \   000015   02....       LJMP      ?BRET
    417          
    418          /*********************************************************************
    419           *                    EXTERNAL I/O FUNCTIONS
    420           *
    421           * User defined functions to control external devices. Add your code
    422           * to the following functions to control devices wired to DB outputs.
    423           *
    424           *********************************************************************/
    425          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    426          void BigLight_On( void )
   \                     BigLight_On:
    427          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    428            // Put code here to turn on an external light
    429          }
   \   000000   02....       LJMP      ?BRET
    430          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    431          void BigLight_Off( void )
   \                     BigLight_Off:
    432          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    433            // Put code here to turn off an external light
    434          }
   \   000000   02....       LJMP      ?BRET
    435          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    436          void BuzzerControl( byte on )
   \                     BuzzerControl:
    437          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    438            // Put code here to turn a buzzer on/off
    439            (void)on;
    440          }
   \   000000   02....       LJMP      ?BRET
    441          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    442          void Dimmer( byte lvl )
   \                     Dimmer:
    443          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    444            // Put code here to control a dimmer
    445            (void)lvl;
    446          }
   \   000000   02....       LJMP      ?BRET
    447          
    448          // No dip switches on this board

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    449          byte GetUserDipSw( void )
   \                     GetUserDipSw:
    450          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    451            return 0;
   \   000000   7900         MOV       R1,#0x0
   \   000002   02....       LJMP      ?BRET
    452          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for registeredKeysTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??InitBoard::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    InitBoard

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??RegisterForKeys::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    RegisterForKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??OnBoard_SendKeys::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OnBoard_SendKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??OnBoard_KeyCallback::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OnBoard_KeyCallback

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??OnBoard_stack_used::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    OnBoard_stack_used

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??_itoa::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _itoa

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Onboard_rand::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Onboard_rand

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Onboard_wait::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Onboard_wait

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BigLight_On::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BigLight_On

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BigLight_Off::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BigLight_Off

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??BuzzerControl::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    BuzzerControl

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??Dimmer::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    Dimmer

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??GetUserDipSw::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GetUserDipSw
    453          
    454          /*********************************************************************
    455          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      0   BigLight_Off
      0      0   BigLight_On
      0      0   BuzzerControl
      0      0   Dimmer
      0      0   GetUserDipSw
      0      9   InitBoard
        0      9   -> HalKeyConfig
        0      9   -> HalLedSet
        0      9   -> Onboard_wait
        0      9   -> osal_int_disable
      0      9   OnBoard_KeyCallback
        0      9   -> OnBoard_SendKeys
      1     19   OnBoard_SendKeys
        0     10   -> osal_msg_allocate
        0     10   -> osal_msg_send
      2      0   OnBoard_stack_used
      0      9   Onboard_rand
        0      9   -> macMcuRandomByte
      0      9   Onboard_wait
      2      0   RegisterForKeys
      1     21   _itoa


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for registeredKeysTaskID>
       5  ?Subroutine0
       7  ?Subroutine1
       3  BigLight_Off
       6  BigLight_Off::?relay
       3  BigLight_On
       6  BigLight_On::?relay
       3  BuzzerControl
       6  BuzzerControl::?relay
       3  Dimmer
       6  Dimmer::?relay
       5  GetUserDipSw
       6  GetUserDipSw::?relay
     104  InitBoard
       6  InitBoard::?relay
      39  OnBoard_KeyCallback
       6  OnBoard_KeyCallback::?relay
      66  OnBoard_SendKeys
       6  OnBoard_SendKeys::?relay
      83  OnBoard_stack_used
       6  OnBoard_stack_used::?relay
       1  OnboardKeyIntEnable
      23  Onboard_rand
       6  Onboard_rand::?relay
      24  Onboard_wait
       6  Onboard_wait::?relay
      19  RegisterForKeys
       6  RegisterForKeys::?relay
       1  SLEEPSTA
       1  _A_IEN0
     154  _itoa
       6  _itoa::?relay
       8  aExtendedAddress
       1  registeredKeysTaskID

 
 541 bytes in segment BANKED_CODE
  78 bytes in segment BANK_RELAYS
   2 bytes in segment SFR_AN
   1 byte  in segment XDATA_I
   1 byte  in segment XDATA_ID
   9 bytes in segment XDATA_Z
 
  79 bytes of CODE     memory
   0 bytes of DATA     memory (+ 2 bytes shared)
 541 bytes of HUGECODE memory
  10 bytes of XDATA    memory

Errors: none
Warnings: none
